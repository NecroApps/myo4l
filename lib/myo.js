// Generated by CoffeeScript 1.8.0
(function() {
  var Emg, EventEmitter, Imu, LOCKING_NONE, LOCKING_STANDARD, Myo, Pose, async, command, constants, noble,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  noble = require('noble');

  constants = require('./constants');

  command = require('./command');

  async = require('async');

  Imu = require('./imu_stream');

  Emg = require('./emg_stream');

  Pose = require('./pose_stream');

  EventEmitter = require('events').EventEmitter;

  LOCKING_NONE = 0;

  LOCKING_STANDARD = 1;

  Myo = (function(_super) {
    __extends(Myo, _super);

    function Myo(devName) {
      this.devName = devName;
      this.onDisconnect = __bind(this.onDisconnect, this);
      this.onRssiUpdate = __bind(this.onRssiUpdate, this);
      this.onConnect = __bind(this.onConnect, this);
      Myo.__super__.constructor.apply(this, arguments);
      this.dev = null;
      this.connected = false;
      this.services = {};
      this.chars = {};
      this.fVersion = null;
      this.imuStream = new Imu();
      this.emgStream = new Emg();
      this.poseStream = new Pose();
      this.imuMode = command.imu.ENABLE;
      this.cfyMode = command.classifier.ENABLE;
      this.emgMode = command.emg.DISABLE;
    }

    Myo.prototype.onConnect = function() {
      return this._discovery((function(_this) {
        return function() {
          return _this.readNecessaryInfo();
        };
      })(this));
    };

    Myo.prototype.onRssiUpdate = function(rssi) {
      return this.emit('rssi', rssi);
    };

    Myo.prototype.onDisconnect = function() {
      this.emit('disconnected');
      return this.connected = false;
    };

    Myo.prototype.disconnect = function() {
      if (this.connected) {
        return this.dev.disconnect();
      }
    };

    Myo.prototype._discovery = function(cb) {
      return this.dev.discoverAllServicesAndCharacteristics((function(_this) {
        return function(err, ss, cs) {
          var c, s, _i, _j, _len, _len1;
          for (_i = 0, _len = ss.length; _i < _len; _i++) {
            s = ss[_i];
            _this.services[s.uuid] = s;
          }
          for (_j = 0, _len1 = cs.length; _j < _len1; _j++) {
            c = cs[_j];
            if (!(c._serviceUuid in _this.chars)) {
              _this.chars[c._serviceUuid] = {};
            }
            _this.chars[c._serviceUuid][c.uuid] = c;
          }
          console.log("done discovery, found " + ss.length + " services, " + cs.length + " characteristics");
          return process.nextTick(function() {
            return cb(err);
          });
        };
      })(this));
    };

    Myo.prototype.getChar = function(suid, cuid, cb) {
      if (suid in this.chars) {
        if (cuid in this.chars[suid]) {
          cb(null, this.chars[suid][cuid]);
          return;
        }
      } else {
        this.chars[suid] = {};
      }
      return this.dev.discoverSomeServicesAndCharacteristics([suid], [cuid], (function(_this) {
        return function(err, ss, cs) {
          if (err) {
            cb(err, null);
            return;
          }
          if (!(ss && cs && ss.length && cs.length)) {
            cb(new Error("charactistic not found"), null);
            return;
          }
          _this.chars[suid][cuid] = cs[0];
          return cb(null, cs[0]);
        };
      })(this));
    };

    Myo.prototype.getService = function(uuid, cb) {
      if (uuid in this.services) {
        cb(null, this.services[uuid]);
        return;
      }
      return this.dev.discoverServices([uuid], (function(_this) {
        return function(err, services) {
          if (!(!err && services && services.length > 0)) {
            if (!err) {
              err = new Error("unknown");
            }
            cb(err, null);
            return;
          }
          _this.services[uuid] = services[0];
          return cb(null, services[0]);
        };
      })(this));
    };

    Myo.prototype.setNotification = function(suid, cuid, enable, indicate, stream, cb) {
      var val, valBuf;
      val = 0x0000;
      if (enable) {
        if (indicate) {
          val = 0x0002;
        } else {
          val = 0x0001;
        }
      } else {
        val = 0x0000;
      }
      valBuf = new Buffer(2);
      valBuf.writeUInt16LE(val, 0);
      return this.getChar(suid, cuid, (function(_this) {
        return function(err, c) {
          if (err) {
            cb(err);
            return;
          }
          c.notify(true);
          if (stream) {
            c.on('read', function(data, notify) {
              if (!notify) {
                return;
              }
              return stream.newData(data);
            });
          }
          return c.discoverDescriptors(function(err, descs) {
            if (err) {
              cb(err);
              return;
            }
            if (descs.length <= 0) {
              cb(new Error('failed to set descriptor'));
              return;
            } else if (descs.length > 1) {
              cb(new Error('unexpected amount of descriptors: ' + cuid));
            }
            return descs[0].writeValue(valBuf, function(err) {
              return cb(err);
            });
          });
        };
      })(this));
    };

    Myo.prototype.writeControlCommand = function(command, cb) {
      return this.getChar(constants.CONTROL_SERVICE_UUID, constants.COMMAND_CHAR_UUID, (function(_this) {
        return function(err, char) {
          return char.write(command, false, function(err) {
            if (!cb) {
              return;
            }
            return cb(err);
          });
        };
      })(this));
    };

    Myo.prototype._vibDuration = {
      'short': 1,
      'medium': 2,
      'long': 3
    };

    Myo.prototype.vibrate = function(duration) {
      if (!(duration in this._vibDuration)) {
        return;
      }
      return this.writeControlCommand(command.getVibrateCommand(this._vibDuration[duration]));
    };

    Myo.prototype.requestRssi = function() {
      return this.dev.updateRssi();
    };

    Myo.prototype._unlockType = {
      'timed': command.unlock.TIMED,
      'hold': command.unlock.HOLD
    };

    Myo.prototype.unlock = function(type) {
      if (!(type in this._unlockType)) {
        return;
      }
      return this.writeControlCommand(command.getUnlockCommand(this._unlockType[type]));
    };

    Myo.prototype.lock = function() {
      this.poseStream.lock();
      return this.emit('locked');
    };

    Myo.prototype._lockingPolicy = {
      'none': LOCKING_NONE,
      'standard': LOCKING_STANDARD
    };

    Myo.prototype.setLockingPolicy = function(type) {
      var lockingPolicy;
      if (!(type in this._lockingPolicy)) {
        return;
      }
      lockingPolicy = this._lockingPolicy[type];
      this.poseStream.setLockingPolicy(lockingPolicy);
      return this.emit('locking_policy_ack', 'success');
    };

    Myo.prototype.getLockingPolicy = function() {
      return this.poseStream.lockingPolicy;
    };

    Myo.prototype.setMode = function(emg, imu, classifier, cb) {
      this.emgMode = emg;
      this.imuMode = imu;
      this.cfyMode = classifier;
      return this.writeControlCommand(command.getSetModeCommand(this.emgMode, this.imuMode, this.cfyMode), cb);
    };

    Myo.prototype.setStreamEmg = function(enable) {
      if (enable === 'enabled') {
        enable = command.emg.STREAM;
      } else {
        enable = command.emg.DISABLE;
      }
      return this.setMode(enable, this.imuMode, this.cfyMode, (function(_this) {
        return function(err) {
          if (err) {
            return _this.emit('set_stream_emg_ack', 'fail');
          } else {
            return _this.emit('set_stream_emg_ack', 'success');
          }
        };
      })(this));
    };

    Myo.prototype.readFrimwareVersion = function() {
      return this.getChar(constants.CONTROL_SERVICE_UUID, constants.FIRMWARE_VERSION_CHAR_UUID, (function(_this) {
        return function(err, c) {
          return c.read(function(err, version) {
            var fVersion, hrd, maj, min, pat;
            maj = version.readUInt16LE(0);
            min = version.readUInt16LE(2);
            pat = version.readUInt16LE(4);
            hrd = version.readUInt16LE(6);
            fVersion = "" + maj + "." + min + "." + pat;
            _this.version = [maj, min, pat, hrd];
            console.log("version: " + fVersion + " hardware: " + hrd);
            _this.connected = true;
            return async.parallel([
              function(cb) {
                return _this.setNotification(constants.EMG_SERVICE_UUID, constants.EMG0_DATA_CHAR_UUID, true, false, _this.emgStream, cb);
              }, function(cb) {
                return _this.setNotification(constants.IMU_SERVICE_UUID, constants.IMU_DATA_CHAR_UUID, true, false, _this.imuStream, cb);
              }, function(cb) {
                return _this.setNotification(constants.FV_SERVICE_UUID, constants.FV_DATA_CHAR_UUID, true, false, null, cb);
              }, function(cb) {
                return _this.setNotification(constants.CLASSIFIER_SERVICE_UUID, constants.CLASSIFIER_EVENT_CHAR_UUID, true, true, _this.poseStream, cb);
              }
            ], function(err) {
              if (err) {
                console.error('failed to set notifications');
                console.error(err);
                return;
              }
              return _this.setMode(command.emg.DISABLE, command.imu.ENABLE, command.classifier.ENABLE, function(err) {
                if (err) {
                  console.error("failed to write init control command", err);
                  return;
                }
                console.log("initialized");
                _this.vibrate('short');
                return _this.emit('connected');
              });
            });
          });
        };
      })(this));
    };

    Myo.prototype.readNecessaryInfo = function() {
      return this.readFrimwareVersion();
    };

    Myo.prototype.initMyo = function() {
      console.log('found myo, connecting...');
      this.dev.on('connect', this.onConnect);
      this.dev.on('disconnect', this.onDisconnect);
      this.dev.on('rssiUpdate', this.onRssiUpdate);
      return this.dev.connect();
    };

    Myo.prototype.connect = function() {
      noble.on('discover', (function(_this) {
        return function(peri) {
          var len;
          len = peri.advertisement.localName.length;
          if (peri.advertisement.localName.substring(0, len - 1) === _this.devName) {
            _this.dev = peri;
            _this.initMyo();
            noble.stopScanning();
          }
        };
      })(this));
      return noble.startScanning();
    };

    return Myo;

  })(EventEmitter);

  module.exports = Myo;

}).call(this);
